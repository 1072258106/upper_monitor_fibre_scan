#pragma once

/************************************************************************/
/*  
 ##   发布的-应变仪通讯协议-带校验数据的版本-多机带返回校验值：  ##

1: 发送指令代码(ASC码)   'B'   功能:   清零,置零(不保存到EPROM).
2: 发送指令代码(ASC码)   'I'   功能:   返回信号电压值(字符格式)
3: 发送指令字符(ASC码)   'K'   后面跟随发送地址:一个字节表示的十六进制数,如0x00 .发送后, 子机返回指令字符"K"和地址,表示寻址成功.指令有效期持续到下一次发送寻址指令.
4: 发送指令字(ASC码)     'M'   功能:   返回带校验和的信号电压值,总共返回五个字节数据,首先返回的是十六进制格式的四字节signed long数据,接收的第一字节是最高字节,第五个字节校验和,是前面四字节之和.

附: 返回字符格式数据便于用串口软件调试.返回十六进制格式数据便于程序处理,并且带校验.

可以用串口助手调试. 

 ##  接线说明：  ##

请查看PCB背板上的标名的端口名称:
VCC ---模块的供电电源正端,接5V电源
GND----模块的供电电源地端,接电源地

E+ ----模块的稳压输出正端,接电桥的正激励
E- ----模块的稳压输出负端,接电桥的负激励
S+ ----接全桥的信号正输出端
S- ----接全桥的信号负输出端

如果测得的AD值为负值,说明信号线接反,将S+ S-连线对调.

注意:上电前要检查输出端,确保E+  E- 没有短接,以免损坏模块稳压源.

                                                                    */
/************************************************************************/

/************************************************************************/
/*             
 ##  称重模块通讯协议-带校验数据的版本-多机带返回校验值  ##

串口通讯默认设置:9600波特率,8位数据,1位停止位,无校验
以下通讯指令,注意,首先要发送寻址指令一次,握手成功后,再发送其它指令(在默认情况下, 模块地址为0. 建议发送0地址的寻址指令时, 以HEX格式发送4A00).
1: 发送指令代码(ASC码)   'A'  功能: 去皮重,清零.
2: 发送指令代码(ASC码)   'H'  功能: 返回重量值(字符格式)
3: 发送指令代码(ASC码)   'I'  功能: 返回AD值(字符格式)
4: 校准零点流程,校零点,先发送指令字 (ASC码)   'G'   启动校准流程 然后发送 指令字  'D' 将需要修正的零点偏移量 保存到EEPROM. 
5: 标定重量,先发送指令字 (ASC码) 'F' , 启动标定重量流程, 然后发送指令字 'D'后面跟随发送一个四字节的 signed long 格式的设定重量值,注意,先发送低位字节,再发送高位字节.
6: 寻址指令:发送指令字符 (ASC码) 'J' , 后面跟随发送地址: 一个字节表示的十六进制数,如0x00. 发送后, 子机返回指令字符 'J' 和地址,表示寻址成功. 指令有效期持续到下一次发送寻址指令.
7: 发送指令字 (ASC码)'K'    返回带校验的AD值,总共返回五个字节数据. 首先返回的是十六进制格式的四字节sined long数据, 接收的第一字节是最高字节,第五个字节校验和,是前面四字节之和.
8: 发送指令字 (ASC码) 'L'   返回带校验和的重量值,总共返回五个字节数据, 首先返回的是十六进制格式的四字节signed long数据, 接收的第一字节是最高字节, 第五个字节校验和, 是前面四字节之和.

附: 返回字符格式数据便于用串口软件调试.返回十六进制格式数据便于程序处理,并且带校验.

可以用串口助手调试. 

关于本模块和传感器的连接: E+连接传感器的电源正(一般是红线) E-连接传感器的电源负(一般是黑线) S+连接传感器的信号正输出 S-连接传感器的信号负输出.如果测试发现AD值为负,那么可以把信号线对换就可以了.

  ##

*/
/************************************************************************/

const char ConfigFilePath[] = "./config.ini";

class CStrainDevice
{
public:
	~CStrainDevice(void);

	static CStrainDevice * Instance();

	bool  Init(void *pParam = NULL);
	void  Release();

	//////////////////////////////////////////////////////////////////////////
	// 寻址指令
	// 下位机将返回指令字
	//  输入： addr， 地址， 
	// 返回：
	//    true， 下位机返回指令字，表示通讯成功
	//    false，下位机没有响应，表示失败。
	//////////////////////////////////////////////////////////////////////////
	bool  RequestAddr(BYTE addr = 0);

	//////////////////////////////////////////////////////////////////////////
	// 读取信号，返回信号AD电压值，字符格式
	// 输出： ad，信号值
	// 返回： true，读取成功
	//////////////////////////////////////////////////////////////////////////
	bool  RequestDataT(long &ad);

	//////////////////////////////////////////////////////////////////////////
	// 读取信号，返回信号AD电压值，二进制格式
	// 输出： ad，信号值
	// 返回： true，读取成功
	//////////////////////////////////////////////////////////////////////////
	bool  RequestDataB(long &ad);

	//////////////////////////////////////////////////////////////////////////
	// 比较输入的信号值是否合法
	// 输入： ad，  信号值
	// 返回：  true，  合法；
	//////////////////////////////////////////////////////////////////////////
	bool  IsAvaliable(long  ad);

	//////////////////////////////////////////////////////////////////////////
	// zero, 保存读取的零值。
	//////////////////////////////////////////////////////////////////////////
	bool  GetZero(long *zero = 0);//校零

protected:


private:
	CStrainDevice(void);
	static CStrainDevice *s_ptrStrainDevice;
	HANDLE          m_hCom;       // 准备打开的串口的句柄

	OVERLAPPED      m_OverlappedWrite;
	OVERLAPPED      m_OverlappedRead;
	CString         m_strIniFile; // 串口配置文件

	// 串口通讯
	bool  InitComm(const char *pFile = ConfigFilePath);

	BOOL  OpenComm(LPCTSTR com);

	void  SetupComm(int baud, int dataSize, int parity, int stopBit);

	DWORD ReadComm(BYTE *buffer, DWORD dwToRead);

	DWORD WriteComm(BYTE *buffer, DWORD dwToWrit);

	void  ReadConfig(LPTSTR lpCom, DWORD &baud, DWORD &dataSize, DWORD &parity, DWORD &stopBit, LPCTSTR cfg_file);

	// 协议相关
	int  m_nZero;
	//int  m_nZeroBase; // 
	int  m_nHighLimit;
	int  m_nLowLimit;

};

